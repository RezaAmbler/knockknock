#!/usr/bin/env python3
"""
Knock Knock Security Scanner

A command-line security scanning tool that uses nmap and ssh-audit to scan
network devices and generate comprehensive HTML security reports.

Example crontab entries:

Run weekly on Sunday at 2 AM:
0 2 * * 0 /usr/bin/flock -n /tmp/knockknock.lock /usr/bin/python3 /path/to/reporting/knockknock/knock_knock.py --targets /path/to/targets.csv --send-email >> /var/log/knockknock.log 2>&1

Run daily at 3 AM without sending email (just generate report):
0 3 * * * /usr/bin/python3 /path/to/reporting/knockknock/knock_knock.py --targets /path/to/targets.csv >> /var/log/knockknock.log 2>&1

Note: Use flock to prevent concurrent runs and full paths for reliability.

Author: Generated by Claude Code
Date: 2025
"""

import argparse
import csv
import ipaddress
import logging
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Set, Tuple

from config import Config
from emailer import EmailSender
from report import HTMLReportGenerator
from scanner import check_tools, scan_hosts_parallel


# ANSI color codes for terminal output
class Colors:
    """ANSI color codes for colorized terminal output."""
    RED = '\033[91m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


def setup_logging() -> None:
    """Configure logging with INFO level and clear format."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )


def display_pps_warning(
    num_hosts: int,
    max_concurrent_hosts: int,
    masscan_rate: int
) -> None:
    """
    Display a colorized warning about expected network PPS generation.

    Args:
        num_hosts: Total number of hosts to scan
        max_concurrent_hosts: Maximum concurrent scans
        masscan_rate: Packet rate per host
    """
    total_pps = max_concurrent_hosts * masscan_rate

    # Choose color based on PPS level
    if total_pps <= 5000:
        pps_color = Colors.GREEN
        safety_msg = "✓ Safe - Low network impact"
    elif total_pps <= 10000:
        pps_color = Colors.CYAN
        safety_msg = "✓ Safe - Moderate network impact"
    elif total_pps <= 20000:
        pps_color = Colors.YELLOW
        safety_msg = "⚠ Caution - High network impact"
    else:
        pps_color = Colors.RED
        safety_msg = "⚠ WARNING - Very high network impact!"

    # Build the warning box
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}  NETWORK PACKET RATE ANALYSIS{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print()
    print(f"  {Colors.WHITE}Total targets:{Colors.RESET}           {Colors.BOLD}{num_hosts}{Colors.RESET} hosts")
    print(f"  {Colors.WHITE}Concurrent scans:{Colors.RESET}        {Colors.BOLD}{max_concurrent_hosts}{Colors.RESET} hosts at a time")
    print(f"  {Colors.WHITE}Masscan rate per host:{Colors.RESET}  {Colors.BOLD}{masscan_rate:,}{Colors.RESET} packets/second")
    print()
    print(f"  {Colors.BOLD}Peak Network Load:{Colors.RESET}")
    print(f"    {max_concurrent_hosts} workers × {masscan_rate:,} pps = {pps_color}{Colors.BOLD}{total_pps:,} packets/second{Colors.RESET}")
    print()
    print(f"  {pps_color}{Colors.BOLD}{safety_msg}{Colors.RESET}")

    if total_pps > 10000:
        print()
        print(f"  {Colors.YELLOW}Recommendation:{Colors.RESET} Consider reducing concurrency or masscan rate")
        print(f"  {Colors.YELLOW}               to keep total PPS under 10,000 for production networks.{Colors.RESET}")

    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print()


def parse_arguments() -> argparse.Namespace:
    """
    Parse command-line arguments.

    Returns:
        Parsed arguments
    """
    parser = argparse.ArgumentParser(
        description='Knock Knock Security Scanner - Automated network security scanning',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --targets targets.csv --send-email
  %(prog)s --targets targets.csv --output-dir /tmp/reports
  %(prog)s --targets targets.csv --html-report custom-report.html

The tool will:
  1. Read device and IP information from CSV
  2. Run nmap and ssh-audit scans in parallel
  3. Generate an HTML security report
  4. Optionally send the report via email
        """
    )

    parser.add_argument(
        '--targets',
        required=True,
        help='Path to CSV file with device_name and wan_ip columns'
    )

    parser.add_argument(
        '--output-dir',
        help='Directory to save reports (default: /tmp/knockknock-YYYYMMDD-HHMMSS/)'
    )

    parser.add_argument(
        '--html-report',
        help='Filename for HTML report (default: knock-knock-YYYYMMDD-HHMMSS.html)'
    )

    parser.add_argument(
        '--send-email',
        action='store_true',
        help='Send email with report (requires valid SMTP config)'
    )

    return parser.parse_args()


def validate_ip(ip: str) -> bool:
    """
    Validate that a string is a valid IPv4 address.

    Args:
        ip: IP address string

    Returns:
        True if valid, False otherwise
    """
    try:
        ipaddress.IPv4Address(ip)
        return True
    except ipaddress.AddressValueError:
        return False


def load_targets(csv_path: Path) -> Tuple[Dict[str, List[str]], List[str]]:
    """
    Load targets from CSV file.

    Expected format:
        device_name,wan_ip
        DAL1-FW1,64.255.192.53
        DAL1-FW1,45.205.47.82

    Args:
        csv_path: Path to CSV file

    Returns:
        Tuple of (device_ip_mapping, all_unique_ips)
        device_ip_mapping: Dictionary mapping device names to list of IPs
        all_unique_ips: List of all unique valid IPs
    """
    logger = logging.getLogger(__name__)

    if not csv_path.exists():
        logger.error(f"CSV file not found: {csv_path}")
        sys.exit(1)

    device_ips: Dict[str, Set[str]] = defaultdict(set)
    seen_rows: Set[Tuple[str, str]] = set()
    invalid_ips = []

    try:
        with open(csv_path, 'r') as f:
            reader = csv.DictReader(f)

            # Validate headers
            if 'device_name' not in reader.fieldnames or 'wan_ip' not in reader.fieldnames:
                logger.error(
                    "CSV must have 'device_name' and 'wan_ip' columns. "
                    f"Found: {reader.fieldnames}"
                )
                sys.exit(1)

            for row_num, row in enumerate(reader, start=2):  # Start at 2 (header is row 1)
                device_name = row.get('device_name', '').strip()
                wan_ip = row.get('wan_ip', '').strip()

                # Skip empty rows
                if not device_name and not wan_ip:
                    continue

                if not device_name:
                    logger.warning(f"Row {row_num}: Missing device_name, skipping")
                    continue

                if not wan_ip:
                    logger.warning(f"Row {row_num}: Missing wan_ip for device {device_name}, skipping")
                    continue

                # Check for duplicates
                row_tuple = (device_name, wan_ip)
                if row_tuple in seen_rows:
                    logger.debug(f"Row {row_num}: Duplicate entry ({device_name}, {wan_ip}), skipping")
                    continue
                seen_rows.add(row_tuple)

                # Validate IP
                if not validate_ip(wan_ip):
                    logger.warning(f"Row {row_num}: Invalid IP address '{wan_ip}', skipping")
                    invalid_ips.append(wan_ip)
                    continue

                # Add to mapping
                device_ips[device_name].add(wan_ip)

    except Exception as e:
        logger.error(f"Error reading CSV file: {e}")
        sys.exit(1)

    # Convert sets to sorted lists
    device_ip_mapping = {
        device: sorted(list(ips))
        for device, ips in device_ips.items()
    }

    # Get all unique IPs
    all_ips = set()
    for ips in device_ip_mapping.values():
        all_ips.update(ips)
    all_unique_ips = sorted(list(all_ips))

    # Log summary
    logger.info(f"Loaded {len(device_ip_mapping)} devices with {len(all_unique_ips)} unique IPs")
    if invalid_ips:
        logger.warning(f"Skipped {len(invalid_ips)} invalid IP addresses")

    return device_ip_mapping, all_unique_ips


def main() -> None:
    """Main entrypoint for knock_knock scanner."""
    setup_logging()
    logger = logging.getLogger(__name__)

    logger.info("=" * 80)
    logger.info("Knock Knock Security Scanner")
    logger.info("=" * 80)

    # Parse arguments
    args = parse_arguments()

    # Load configuration
    logger.info("Loading configuration...")
    config = Config()

    # Validate email configuration if --send-email is specified
    if args.send_email:
        if not config.validate_email_config():
            logger.error("Email sending requested but SMTP configuration is invalid")
            sys.exit(1)

    # Pre-flight check: verify required tools are available
    logger.info("Checking for required tools (masscan, nmap, ssh-audit)...")
    tools_ok, missing_tools = check_tools()

    if not tools_ok:
        logger.error(f"Required tools not found in PATH: {', '.join(missing_tools)}")
        logger.error("Please install missing tools:")
        for tool in missing_tools:
            if tool == 'masscan':
                logger.error("  - masscan: sudo apt-get install masscan")
            elif tool == 'nmap':
                logger.error("  - nmap: sudo apt-get install nmap")
            elif tool == 'ssh-audit':
                logger.error("  - ssh-audit: sudo apt-get install ssh-audit")
        sys.exit(1)

    logger.info("All required tools are available")

    # Load targets from CSV
    logger.info(f"Loading targets from {args.targets}...")
    targets_path = Path(args.targets)
    device_ip_mapping, all_ips = load_targets(targets_path)

    # Set up output directory
    if args.output_dir:
        output_dir = Path(args.output_dir)
    else:
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        output_dir = Path(f'/tmp/knockknock-{timestamp}')

    output_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_dir}")

    # Set up HTML report path
    if args.html_report:
        html_report_path = output_dir / args.html_report
    else:
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        html_report_path = output_dir / f'knock-knock-{timestamp}.html'

    # Handle empty target list
    if not all_ips:
        logger.warning("No valid targets found in CSV")

        # Generate "no targets" report
        report_gen = HTMLReportGenerator(
            report_title=config.report_title,
            ports_of_interest=config.ports_of_interest
        )

        start_time = datetime.now()
        html_content = report_gen.generate(
            device_ip_mapping={},
            scan_results=[],
            start_time=start_time,
            end_time=datetime.now()
        )

        # Save report
        with open(html_report_path, 'w') as f:
            f.write(html_content)
        logger.info(f"Generated 'no targets' report: {html_report_path}")

        # Send email if requested
        if args.send_email:
            logger.info("Sending email...")
            sender = EmailSender(
                smtp_host=config.smtp_host,
                smtp_port=config.smtp_port,
                smtp_use_tls=config.smtp_use_tls,
                from_address=config.from_address,
                to_addresses=config.to_addresses,
                subject_prefix=config.subject_prefix
            )

            if sender.send_report(html_content, html_report_path):
                logger.info("Email sent successfully")
            else:
                logger.error("Failed to send email (scan completed successfully)")

        logger.info("Scan complete (no targets)")
        sys.exit(0)

    # Display PPS warning before starting scans
    display_pps_warning(
        num_hosts=len(all_ips),
        max_concurrent_hosts=config.max_concurrent_hosts,
        masscan_rate=config.masscan_rate
    )

    # Run scans
    logger.info("=" * 80)
    logger.info("Starting two-stage security scans (masscan → nmap → ssh-audit)")
    logger.info(f"Targets: {len(all_ips)} unique IPs")
    logger.info(f"Concurrency: {config.max_concurrent_hosts} workers")
    logger.info(f"Masscan rate: {config.masscan_rate} pps/host")
    total_pps = config.max_concurrent_hosts * config.masscan_rate
    logger.info(f"Max total PPS: {total_pps:,} ({config.max_concurrent_hosts} workers × {config.masscan_rate} pps)")
    logger.info(f"Timeout: {config.host_timeout_seconds} seconds per host")
    logger.info("=" * 80)

    start_time = datetime.now()

    scan_results = scan_hosts_parallel(
        ips=all_ips,
        masscan_binary=config.masscan_binary,
        masscan_rate=config.masscan_rate,
        nmap_binary=config.nmap_binary,
        nmap_args=config.nmap_args,
        ssh_audit_binary=config.ssh_audit_binary,
        ssh_ports=config.ssh_ports,
        output_dir=output_dir,
        max_workers=config.max_concurrent_hosts,
        timeout_seconds=config.host_timeout_seconds
    )

    end_time = datetime.now()
    duration = end_time - start_time

    logger.info("=" * 80)
    logger.info(f"Scans completed in {duration}")
    logger.info("=" * 80)

    # Generate HTML report
    logger.info("Generating HTML report...")

    report_gen = HTMLReportGenerator(
        report_title=config.report_title,
        ports_of_interest=config.ports_of_interest
    )

    html_content = report_gen.generate(
        device_ip_mapping=device_ip_mapping,
        scan_results=scan_results,
        start_time=start_time,
        end_time=end_time
    )

    # Save HTML report
    with open(html_report_path, 'w') as f:
        f.write(html_content)

    logger.info(f"HTML report saved: {html_report_path}")

    # Send email if requested
    if args.send_email:
        logger.info("Sending email...")

        sender = EmailSender(
            smtp_host=config.smtp_host,
            smtp_port=config.smtp_port,
            smtp_use_tls=config.smtp_use_tls,
            from_address=config.from_address,
            to_addresses=config.to_addresses,
            subject_prefix=config.subject_prefix
        )

        if sender.send_report(html_content, html_report_path):
            logger.info("Email sent successfully")
        else:
            logger.error("Failed to send email (scan completed successfully)")

    logger.info("=" * 80)
    logger.info("Knock Knock scan complete")
    logger.info("=" * 80)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        logging.error(f"Unexpected error: {e}", exc_info=True)
        sys.exit(1)
