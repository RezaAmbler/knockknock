#!/usr/bin/env python3
"""
Knock Knock Security Scanner

A command-line security scanning tool that uses nmap and ssh-audit to scan
network devices and generate comprehensive HTML security reports.

Example crontab entries:

Run weekly on Sunday at 2 AM:
0 2 * * 0 /usr/bin/flock -n /tmp/knockknock.lock /usr/bin/python3 /path/to/reporting/knockknock/knock_knock.py --targets /path/to/targets.csv --send-email >> /var/log/knockknock.log 2>&1

Run daily at 3 AM without sending email (just generate report):
0 3 * * * /usr/bin/python3 /path/to/reporting/knockknock/knock_knock.py --targets /path/to/targets.csv >> /var/log/knockknock.log 2>&1

Note: Use flock to prevent concurrent runs and full paths for reliability.

Author: Generated by Claude Code
Date: 2025
"""

import argparse
import csv
import ipaddress
import logging
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

from config import Config
from emailer import EmailSender
from report import HTMLReportGenerator
from scanner import check_tools, scan_hosts_parallel
from storage import (
    RunMetadata,
    PortSummaryRow,
    compute_hash,
    record_run,
    query_ports_summary,
    get_db_stats
)


# ANSI color codes for terminal output
class Colors:
    """ANSI color codes for colorized terminal output."""
    RED = '\033[91m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


def setup_logging(quiet: bool = False, debug: bool = False) -> None:
    """
    Configure logging with appropriate level and format.

    Args:
        quiet: If True, only show WARNING and ERROR messages
        debug: If True, show DEBUG level messages and log to tmp/debug.log
    """
    if debug:
        level = logging.DEBUG
    elif quiet:
        level = logging.WARNING
    else:
        level = logging.INFO

    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)

    # Get root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.addHandler(console_handler)

    # If debug mode, also log to file
    if debug:
        # Ensure tmp/ directory exists
        tmp_dir = Path('tmp')
        tmp_dir.mkdir(exist_ok=True)

        # Create timestamped log file
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        log_file = tmp_dir / f'debug-{timestamp}.log'

        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)

        # Log the file location
        root_logger.info(f"Debug logging enabled - writing to {log_file}")


def display_pps_warning(
    num_hosts: int,
    max_concurrent_hosts: int,
    masscan_rate: int
) -> None:
    """
    Display a colorized warning about expected network PPS generation.

    Args:
        num_hosts: Total number of hosts to scan
        max_concurrent_hosts: Maximum concurrent scans
        masscan_rate: Packet rate per host
    """
    total_pps = max_concurrent_hosts * masscan_rate

    # Choose color based on PPS level
    if total_pps <= 5000:
        pps_color = Colors.GREEN
        safety_msg = "✓ Safe - Low network impact"
    elif total_pps <= 10000:
        pps_color = Colors.CYAN
        safety_msg = "✓ Safe - Moderate network impact"
    elif total_pps <= 20000:
        pps_color = Colors.YELLOW
        safety_msg = "⚠ Caution - High network impact"
    else:
        pps_color = Colors.RED
        safety_msg = "⚠ WARNING - Very high network impact!"

    # Build the warning box
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}  NETWORK PACKET RATE ANALYSIS{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print()
    print(f"  {Colors.WHITE}Total targets:{Colors.RESET}           {Colors.BOLD}{num_hosts}{Colors.RESET} hosts")
    print(f"  {Colors.WHITE}Concurrent scans:{Colors.RESET}        {Colors.BOLD}{max_concurrent_hosts}{Colors.RESET} hosts at a time")
    print(f"  {Colors.WHITE}Masscan rate per host:{Colors.RESET}  {Colors.BOLD}{masscan_rate:,}{Colors.RESET} packets/second")
    print()
    print(f"  {Colors.BOLD}Peak Network Load:{Colors.RESET}")
    print(f"    {max_concurrent_hosts} workers × {masscan_rate:,} pps = {pps_color}{Colors.BOLD}{total_pps:,} packets/second{Colors.RESET}")
    print()
    print(f"  {pps_color}{Colors.BOLD}{safety_msg}{Colors.RESET}")

    if total_pps > 10000:
        print()
        print(f"  {Colors.YELLOW}Recommendation:{Colors.RESET} Consider reducing concurrency or masscan rate")
        print(f"  {Colors.YELLOW}               to keep total PPS under 10,000 for production networks.{Colors.RESET}")

    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{'═' * 80}{Colors.RESET}")
    print()


def parse_arguments() -> argparse.Namespace:
    """
    Parse command-line arguments.

    Returns:
        Parsed arguments
    """
    parser = argparse.ArgumentParser(
        description='Knock Knock Security Scanner - Automated network security scanning',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --targets targets.csv --send-email
  %(prog)s --targets targets.csv --output-dir /tmp/reports
  %(prog)s --targets targets.csv --html-report custom-report.html

The tool will:
  1. Read device and IP information from CSV
  2. Run nmap and ssh-audit scans in parallel
  3. Generate an HTML security report
  4. Optionally send the report via email
        """
    )

    # Scanning mode arguments
    scan_group = parser.add_argument_group('scanning mode')
    scan_group.add_argument(
        '--targets',
        help='Path to CSV file with device_name and wan_ip columns (required for scan mode)'
    )

    scan_group.add_argument(
        '--output-dir',
        help='Directory to save reports (default: /tmp/knockknock-YYYYMMDD-HHMMSS/)'
    )

    scan_group.add_argument(
        '--html-report',
        help='Filename for HTML report (default: knock-knock-YYYYMMDD-HHMMSS.html)'
    )

    scan_group.add_argument(
        '--send-email',
        action='store_true',
        help='Send email with report (requires valid SMTP config)'
    )

    scan_group.add_argument(
        '--test-email',
        action='store_true',
        help='Send a test email and exit (validates SMTP configuration)'
    )

    # Verbosity arguments (mutually exclusive)
    verbosity_group = scan_group.add_mutually_exclusive_group()

    verbosity_group.add_argument(
        '--quiet',
        action='store_true',
        help='Reduce log output (only show warnings and errors)'
    )

    verbosity_group.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug logging (shows commands, detailed errors, and diagnostics)'
    )

    # Database arguments
    db_group = parser.add_argument_group('database logging')
    db_group.add_argument(
        '--db-path',
        type=Path,
        help='Path to SQLite database (enables DB logging and overrides config)'
    )

    db_group.add_argument(
        '--no-db',
        action='store_true',
        help='Explicitly disable database logging (overrides config)'
    )

    # Reporting mode arguments
    report_group = parser.add_argument_group('reporting mode')
    report_group.add_argument(
        '--report',
        choices=['ports'],
        help='Generate report from database (currently supports: ports)'
    )

    report_group.add_argument(
        '--from',
        dest='from_date',
        help='Start datetime for report range (ISO-8601 format: YYYY-MM-DDTHH:MM:SSZ, default: earliest)'
    )

    report_group.add_argument(
        '--to',
        dest='to_date',
        help='End datetime for report range (ISO-8601 format: YYYY-MM-DDTHH:MM:SSZ, default: now)'
    )

    report_group.add_argument(
        '--host',
        help='Filter report by hostname or IP (optional)'
    )

    report_group.add_argument(
        '--port',
        type=int,
        help='Filter report by port number (optional)'
    )

    report_group.add_argument(
        '--output',
        choices=['table', 'csv'],
        default='table',
        help='Output format for reports (default: table)'
    )

    return parser.parse_args()


def validate_ip(ip: str) -> bool:
    """
    Validate that a string is a valid IPv4 address.

    Args:
        ip: IP address string

    Returns:
        True if valid, False otherwise
    """
    try:
        ipaddress.IPv4Address(ip)
        return True
    except ipaddress.AddressValueError:
        return False


def load_targets(csv_path: Path) -> Tuple[Dict[str, List[str]], List[str]]:
    """
    Load targets from CSV file.

    Expected format:
        device_name,wan_ip
        DAL1-FW1,64.255.192.53
        DAL1-FW1,45.205.47.82

    Args:
        csv_path: Path to CSV file

    Returns:
        Tuple of (device_ip_mapping, all_unique_ips)
        device_ip_mapping: Dictionary mapping device names to list of IPs
        all_unique_ips: List of all unique valid IPs
    """
    logger = logging.getLogger(__name__)

    if not csv_path.exists():
        logger.error(f"CSV file not found: {csv_path}")
        sys.exit(1)

    device_ips: Dict[str, Set[str]] = defaultdict(set)
    seen_rows: Set[Tuple[str, str]] = set()
    invalid_ips = []

    try:
        with open(csv_path, 'r') as f:
            reader = csv.DictReader(f)

            # Validate headers
            if 'device_name' not in reader.fieldnames or 'wan_ip' not in reader.fieldnames:
                logger.error(
                    "CSV must have 'device_name' and 'wan_ip' columns. "
                    f"Found: {reader.fieldnames}"
                )
                sys.exit(1)

            for row_num, row in enumerate(reader, start=2):  # Start at 2 (header is row 1)
                device_name = row.get('device_name', '').strip()
                wan_ip = row.get('wan_ip', '').strip()

                # Skip empty rows
                if not device_name and not wan_ip:
                    continue

                if not device_name:
                    logger.warning(f"Row {row_num}: Missing device_name, skipping")
                    continue

                if not wan_ip:
                    logger.warning(f"Row {row_num}: Missing wan_ip for device {device_name}, skipping")
                    continue

                # Check for duplicates
                row_tuple = (device_name, wan_ip)
                if row_tuple in seen_rows:
                    logger.debug(f"Row {row_num}: Duplicate entry ({device_name}, {wan_ip}), skipping")
                    continue
                seen_rows.add(row_tuple)

                # Validate IP
                if not validate_ip(wan_ip):
                    logger.warning(f"Row {row_num}: Invalid IP address '{wan_ip}', skipping")
                    invalid_ips.append(wan_ip)
                    continue

                # Add to mapping
                device_ips[device_name].add(wan_ip)

    except Exception as e:
        logger.error(f"Error reading CSV file: {e}")
        sys.exit(1)

    # Convert sets to sorted lists
    device_ip_mapping = {
        device: sorted(list(ips))
        for device, ips in device_ips.items()
    }

    # Get all unique IPs
    all_ips = set()
    for ips in device_ip_mapping.values():
        all_ips.update(ips)
    all_unique_ips = sorted(list(all_ips))

    # Log summary
    logger.info(f"Loaded {len(device_ip_mapping)} devices with {len(all_unique_ips)} unique IPs")
    if invalid_ips:
        logger.warning(f"Skipped {len(invalid_ips)} invalid IP addresses")

    return device_ip_mapping, all_unique_ips


def parse_datetime(dt_str: Optional[str], default: str) -> str:
    """
    Parse and validate ISO-8601 datetime string.

    Args:
        dt_str: DateTime string in ISO-8601 format (YYYY-MM-DDTHH:MM:SSZ)
        default: Default value if dt_str is None

    Returns:
        Validated ISO-8601 datetime string

    Raises:
        ValueError: If datetime string is invalid
    """
    if dt_str is None:
        return default

    try:
        # Validate by parsing
        datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
        return dt_str
    except ValueError as e:
        raise ValueError(
            f"Invalid datetime format: {dt_str}. "
            f"Expected ISO-8601 format like: 2025-01-01T00:00:00Z"
        ) from e


def print_ports_table(rows: List[PortSummaryRow]) -> None:
    """
    Print port summary rows as a formatted table.

    Args:
        rows: List of PortSummaryRow objects
    """
    if not rows:
        print("No ports found in the specified time range.")
        return

    # Define column widths
    col_widths = {
        'device': max(len(row.device_name) for row in rows) + 2,
        'ip': max(len(row.ip) for row in rows) + 2,
        'port': 6,
        'proto': 7,
        'first': 25,
        'last': 25,
        'runs': 6,
        'product': 18,
        'version': 16
    }

    # Ensure minimum widths for headers
    col_widths['device'] = max(col_widths['device'], 16)
    col_widths['ip'] = max(col_widths['ip'], 17)

    # Print header
    header = (
        f"{'HOSTNAME':<{col_widths['device']}} "
        f"{'IP':<{col_widths['ip']}} "
        f"{'PORT':<{col_widths['port']}} "
        f"{'PROTO':<{col_widths['proto']}} "
        f"{'FIRST_SEEN':<{col_widths['first']}} "
        f"{'LAST_SEEN':<{col_widths['last']}} "
        f"{'RUNS':<{col_widths['runs']}} "
        f"{'PRODUCT':<{col_widths['product']}} "
        f"{'VERSION':<{col_widths['version']}}"
    )
    print(header)
    print("-" * len(header))

    # Print rows
    for row in rows:
        product = (row.last_product or '')[:col_widths['product']-1]
        version = (row.last_version or '')[:col_widths['version']-1]

        print(
            f"{row.device_name:<{col_widths['device']}} "
            f"{row.ip:<{col_widths['ip']}} "
            f"{row.port:<{col_widths['port']}} "
            f"{row.protocol:<{col_widths['proto']}} "
            f"{row.first_seen_at:<{col_widths['first']}} "
            f"{row.last_seen_at:<{col_widths['last']}} "
            f"{row.runs_count:<{col_widths['runs']}} "
            f"{product:<{col_widths['product']}} "
            f"{version:<{col_widths['version']}}"
        )

    print()
    print(f"Total: {len(rows)} unique port(s)")


def print_ports_csv(rows: List[PortSummaryRow]) -> None:
    """
    Print port summary rows as CSV.

    Args:
        rows: List of PortSummaryRow objects
    """
    # Print header
    print("device_name,ip,port,protocol,first_seen_at,last_seen_at,runs_count,last_product,last_version")

    # Print rows
    for row in rows:
        product = row.last_product or ''
        version = row.last_version or ''
        print(
            f"{row.device_name},{row.ip},{row.port},{row.protocol},"
            f"{row.first_seen_at},{row.last_seen_at},{row.runs_count},"
            f"{product},{version}"
        )


def run_report_mode(args: argparse.Namespace, config: Config) -> None:
    """
    Run in report mode - query database and generate report.

    Args:
        args: Parsed command-line arguments
        config: Configuration object
    """
    logger = logging.getLogger(__name__)

    # Determine database path
    if args.db_path:
        db_path = args.db_path
    elif config.database_enabled:
        db_path = Path(config.database_path)
    else:
        logger.error("Report mode requires a database. Use --db-path or enable database in config.yaml")
        sys.exit(1)

    if not db_path.exists():
        logger.error(f"Database not found: {db_path}")
        sys.exit(1)

    logger.info(f"Reading from database: {db_path}")

    # Show database stats
    stats = get_db_stats(db_path)
    logger.info(
        f"Database contains {stats.get('total_runs', 0)} runs, "
        f"{stats.get('total_hosts', 0)} host scans, "
        f"{stats.get('total_ports', 0)} port records"
    )
    if stats.get('first_run'):
        logger.info(f"Date range: {stats.get('first_run')} to {stats.get('last_run')}")

    # Parse date range
    try:
        from_dt = parse_datetime(args.from_date, '0001-01-01T00:00:00Z')
        to_dt = parse_datetime(args.to_date, datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'))
    except ValueError as e:
        logger.error(str(e))
        sys.exit(1)

    logger.info(f"Report time range: {from_dt} to {to_dt}")

    # Run the appropriate report
    if args.report == 'ports':
        logger.info("Generating ports report...")

        rows = query_ports_summary(
            db_path=db_path,
            from_dt=from_dt,
            to_dt=to_dt,
            host_filter=args.host,
            port_filter=args.port
        )

        # Print results
        if args.output == 'csv':
            print_ports_csv(rows)
        else:
            print()
            print_ports_table(rows)

    logger.info("Report complete")


def run_test_email_mode(config: Config) -> None:
    """
    Send a test email to validate SMTP configuration.

    Args:
        config: Configuration object
    """
    logger = logging.getLogger(__name__)

    logger.info("=" * 80)
    logger.info("Test Email Mode")
    logger.info("=" * 80)

    # Validate email configuration
    if not config.validate_email_config():
        logger.error("SMTP configuration is invalid")
        sys.exit(1)

    logger.info("SMTP configuration is valid")
    logger.info(f"SMTP Host: {config.smtp_host}")
    logger.info(f"SMTP Port: {config.smtp_port}")
    logger.info(f"Use TLS: {config.smtp_use_tls}")
    logger.info(f"From: {config.from_address}")
    logger.info(f"To: {', '.join(config.to_addresses)}")

    if config.smtp_username:
        logger.info(f"Username: {config.smtp_username}")
    else:
        logger.info("Username: (not configured)")

    if config.smtp_password:
        logger.info("Password: (configured)")
    else:
        logger.info("Password: (not configured)")

    logger.info("")
    logger.info("Sending test email...")

    # Create a simple test HTML report
    test_html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Knock Knock Test Email</title>
</head>
<body style="font-family: Arial, sans-serif; padding: 20px;">
    <h1 style="color: #2c3e50;">Knock Knock Test Email</h1>
    <p>This is a test email from the Knock Knock Security Scanner.</p>

    <h2 style="color: #34495e;">Configuration Summary</h2>
    <table style="border-collapse: collapse; width: 100%; max-width: 600px;">
        <tr style="background-color: #ecf0f1;">
            <td style="padding: 8px; border: 1px solid #bdc3c7;"><strong>SMTP Host</strong></td>
            <td style="padding: 8px; border: 1px solid #bdc3c7;">{config.smtp_host}</td>
        </tr>
        <tr>
            <td style="padding: 8px; border: 1px solid #bdc3c7;"><strong>SMTP Port</strong></td>
            <td style="padding: 8px; border: 1px solid #bdc3c7;">{config.smtp_port}</td>
        </tr>
        <tr style="background-color: #ecf0f1;">
            <td style="padding: 8px; border: 1px solid #bdc3c7;"><strong>Use TLS</strong></td>
            <td style="padding: 8px; border: 1px solid #bdc3c7;">{config.smtp_use_tls}</td>
        </tr>
        <tr>
            <td style="padding: 8px; border: 1px solid #bdc3c7;"><strong>Authentication</strong></td>
            <td style="padding: 8px; border: 1px solid #bdc3c7;">{'Enabled' if config.smtp_username else 'Disabled'}</td>
        </tr>
    </table>

    <p style="margin-top: 20px; color: #27ae60;">
        <strong>✓ If you received this email, your SMTP configuration is working correctly!</strong>
    </p>

    <hr style="margin-top: 30px; border: none; border-top: 1px solid #bdc3c7;">
    <p style="color: #7f8c8d; font-size: 12px;">
        Generated by Knock Knock Security Scanner on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    </p>
</body>
</html>"""

    # Create a temporary file for the HTML attachment
    import tempfile
    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
        f.write(test_html)
        temp_html_path = Path(f.name)

    try:
        # Create EmailSender
        sender = EmailSender(
            smtp_host=config.smtp_host,
            smtp_port=config.smtp_port,
            smtp_use_tls=config.smtp_use_tls,
            from_address=config.from_address,
            to_addresses=config.to_addresses,
            subject_prefix="Knock Knock Test Email",
            smtp_username=config.smtp_username,
            smtp_password=config.smtp_password
        )

        # Send test email
        if sender.send_report(test_html, temp_html_path):
            logger.info("")
            logger.info("=" * 80)
            logger.info("✓ Test email sent successfully!")
            logger.info("=" * 80)
            logger.info("")
            logger.info("Check your inbox at: " + ', '.join(config.to_addresses))
            sys.exit(0)
        else:
            logger.error("")
            logger.error("=" * 80)
            logger.error("✗ Failed to send test email")
            logger.error("=" * 80)
            logger.error("")
            logger.error("Please check the error messages above and verify your SMTP configuration")
            sys.exit(1)

    finally:
        # Clean up temporary file
        if temp_html_path.exists():
            temp_html_path.unlink()


def main() -> None:
    """Main entrypoint for knock_knock scanner."""
    # Parse arguments first to get quiet flag
    args = parse_arguments()

    # Setup logging with quiet/debug flags
    setup_logging(quiet=args.quiet, debug=args.debug)
    logger = logging.getLogger(__name__)

    logger.info("=" * 80)
    logger.info("Knock Knock Security Scanner")
    logger.info("=" * 80)

    # Load configuration
    logger.info("Loading configuration...")
    config = Config()

    # Check if we're in report mode
    if args.report:
        run_report_mode(args, config)
        return

    # Check if we're in test email mode
    if args.test_email:
        run_test_email_mode(config)
        return

    # Scanning mode - validate required arguments
    if not args.targets:
        logger.error("--targets is required for scanning mode")
        sys.exit(1)

    # Validate email configuration if --send-email is specified
    if args.send_email:
        if not config.validate_email_config():
            logger.error("Email sending requested but SMTP configuration is invalid")
            sys.exit(1)

    # Pre-flight check: verify required tools are available
    logger.info("Checking for required tools (masscan, nmap, ssh-audit)...")
    tools_ok, missing_tools = check_tools()

    if not tools_ok:
        logger.error(f"Required tools not found in PATH: {', '.join(missing_tools)}")
        logger.error("Please install missing tools:")
        for tool in missing_tools:
            if tool == 'masscan':
                logger.error("  - masscan: sudo apt-get install masscan")
            elif tool == 'nmap':
                logger.error("  - nmap: sudo apt-get install nmap")
            elif tool == 'ssh-audit':
                logger.error("  - ssh-audit: sudo apt-get install ssh-audit")
        sys.exit(1)

    logger.info("All required tools are available")

    # Load targets from CSV
    logger.info(f"Loading targets from {args.targets}...")
    targets_path = Path(args.targets)
    device_ip_mapping, all_ips = load_targets(targets_path)

    # Set up output directory
    if args.output_dir:
        output_dir = Path(args.output_dir)
    else:
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        output_dir = Path(f'/tmp/knockknock-{timestamp}')

    output_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_dir}")

    # Set up HTML report path
    if args.html_report:
        html_report_path = output_dir / args.html_report
    else:
        timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
        html_report_path = output_dir / f'knock-knock-{timestamp}.html'

    # Handle empty target list
    if not all_ips:
        logger.warning("No valid targets found in CSV")

        # Generate "no targets" report
        report_gen = HTMLReportGenerator(
            report_title=config.report_title,
            ports_of_interest=config.ports_of_interest
        )

        start_time = datetime.now()
        html_content = report_gen.generate(
            device_ip_mapping={},
            scan_results=[],
            start_time=start_time,
            end_time=datetime.now()
        )

        # Save report
        with open(html_report_path, 'w') as f:
            f.write(html_content)
        logger.info(f"Generated 'no targets' report: {html_report_path}")

        # Send email if requested
        if args.send_email:
            logger.info("Sending email...")
            sender = EmailSender(
                smtp_host=config.smtp_host,
                smtp_port=config.smtp_port,
                smtp_use_tls=config.smtp_use_tls,
                from_address=config.from_address,
                to_addresses=config.to_addresses,
                subject_prefix=config.subject_prefix,
                smtp_username=config.smtp_username,
                smtp_password=config.smtp_password
            )

            if sender.send_report(html_content, html_report_path):
                logger.info("Email sent successfully")
            else:
                logger.error("Failed to send email (scan completed successfully)")

        logger.info("Scan complete (no targets)")
        sys.exit(0)

    # Display PPS warning before starting scans (unless in quiet mode)
    if not args.quiet:
        display_pps_warning(
            num_hosts=len(all_ips),
            max_concurrent_hosts=config.max_concurrent_hosts,
            masscan_rate=config.masscan_rate
        )

    # Run scans
    logger.info("=" * 80)
    logger.info("Starting two-stage security scans (masscan → nmap → ssh-audit)")
    logger.info(f"Targets: {len(all_ips)} unique IPs")
    logger.info(f"Concurrency: {config.max_concurrent_hosts} workers")
    logger.info(f"Masscan rate: {config.masscan_rate} pps/host")
    total_pps = config.max_concurrent_hosts * config.masscan_rate
    logger.info(f"Max total PPS: {total_pps:,} ({config.max_concurrent_hosts} workers × {config.masscan_rate} pps)")
    logger.info(f"Timeout: {config.host_timeout_seconds} seconds per host")
    logger.info("=" * 80)

    start_time = datetime.now()

    scan_results = scan_hosts_parallel(
        ips=all_ips,
        masscan_binary=config.masscan_binary,
        masscan_rate=config.masscan_rate,
        nmap_binary=config.nmap_binary,
        nmap_args=config.nmap_args,
        ssh_audit_binary=config.ssh_audit_binary,
        ssh_ports=config.ssh_ports,
        output_dir=output_dir,
        max_workers=config.max_concurrent_hosts,
        timeout_seconds=config.host_timeout_seconds
    )

    end_time = datetime.now()
    duration = end_time - start_time

    logger.info("=" * 80)
    logger.info(f"Scans completed in {duration}")
    logger.info("=" * 80)

    # Generate HTML report
    logger.info("Generating HTML report...")

    report_gen = HTMLReportGenerator(
        report_title=config.report_title,
        ports_of_interest=config.ports_of_interest
    )

    html_content = report_gen.generate(
        device_ip_mapping=device_ip_mapping,
        scan_results=scan_results,
        start_time=start_time,
        end_time=end_time
    )

    # Save HTML report
    with open(html_report_path, 'w') as f:
        f.write(html_content)

    logger.info(f"HTML report saved: {html_report_path}")

    # Send email if requested
    if args.send_email:
        logger.info("Sending email...")

        sender = EmailSender(
            smtp_host=config.smtp_host,
            smtp_port=config.smtp_port,
            smtp_use_tls=config.smtp_use_tls,
            from_address=config.from_address,
            to_addresses=config.to_addresses,
            subject_prefix=config.subject_prefix,
            smtp_username=config.smtp_username,
            smtp_password=config.smtp_password
        )

        if sender.send_report(html_content, html_report_path):
            logger.info("Email sent successfully")
        else:
            logger.error("Failed to send email (scan completed successfully)")

    # Record to database if enabled
    # Precedence: --no-db disables, --db-path enables, otherwise use config
    should_log_db = False
    db_log_path = None

    if not args.no_db:
        if args.db_path:
            should_log_db = True
            db_log_path = args.db_path
        elif config.database_enabled:
            should_log_db = True
            db_log_path = Path(config.database_path)

    if should_log_db and db_log_path:
        logger.info(f"Recording scan results to database: {db_log_path}")

        try:
            # Read targets file content for hashing
            targets_content = targets_path.read_text()
            targets_hash = compute_hash(targets_content)

            # Compute config hash from relevant settings
            config_dict = {
                'masscan_rate': config.masscan_rate,
                'nmap_args': config.nmap_args,
                'ssh_ports': config.ssh_ports,
                'max_concurrent_hosts': config.max_concurrent_hosts,
                'host_timeout_seconds': config.host_timeout_seconds
            }
            config_hash = compute_hash(str(sorted(config_dict.items())))

            # Build run metadata
            run_meta = RunMetadata(
                started_at=start_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                finished_at=end_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                config_hash=config_hash,
                targets_hash=targets_hash,
                cli_args=' '.join(sys.argv[1:])
            )

            # Record to database
            record_run(
                db_path=db_log_path,
                run_meta=run_meta,
                results=scan_results,
                device_mapping=device_ip_mapping
            )

            logger.info("Scan results recorded to database successfully")

        except Exception as e:
            logger.warning(f"Failed to record scan to database: {e}")
            # Don't fail the scan due to DB errors

    logger.info("=" * 80)
    logger.info("Knock Knock scan complete")
    logger.info("=" * 80)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        logging.error(f"Unexpected error: {e}", exc_info=True)
        sys.exit(1)
